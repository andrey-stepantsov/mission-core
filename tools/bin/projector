#!/usr/bin/env python3
import argparse
import os
import sys
import subprocess
import json
import shutil
import time
import threading

HOLOGRAM_DIR = "hologram"
OUTSIDE_WALL_DIR = "outside_wall"
CONFIG_FILE = ".hologram_config"

def run_command(cmd, shell=False, capture_stderr=True):
    """Runs a shell command and returns stdout."""
    try:
        stderr_dest = subprocess.PIPE if capture_stderr else sys.stderr
        result = subprocess.run(cmd, shell=shell, check=True, stdout=subprocess.PIPE, stderr=stderr_dest, text=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        # Check if stderr is just noise (warnings)
        err_msg = e.stderr if e.stderr else ""
        lines = err_msg.splitlines()
        real_errors = [l for l in lines if not (l.startswith("Warning:") or "setlocale" in l)]
        
        if real_errors:
            print(f"Error running command: {cmd}")
            print(f"Stderr: {err_msg}")
        elif not capture_stderr:
             # If we weren't capturing, typically means interactive or we don't care about output unless failed
            print(f"Command failed with exit code {e.returncode}: {cmd}")
            
        raise e  # Re-raise so caller handles flow

def load_config():
    if not os.path.exists(CONFIG_FILE):
        print("Error: Hologram not initialized. Run 'projector init <host>' first.")
        sys.exit(1)
    with open(CONFIG_FILE, 'r') as f:
        return json.load(f)

def save_config(config):
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=4)


def do_init(args):
    """Initializes the hologram environment."""
    host_target = args.host_target
    remote_root = args.remote_root.rstrip("/") if args.remote_root else "."
    
    print(f"Initializing Hologram for host: {host_target} (Root: {remote_root})")
    
    os.makedirs(HOLOGRAM_DIR, exist_ok=True)
    os.makedirs(OUTSIDE_WALL_DIR, exist_ok=True)
    
    config = {
        "host_target": host_target,
        "remote_root": remote_root
    }
    save_config(config)
    print("Hologram initialized.")
    
    # 4. Launch The Tower (Observability)
    print("Launching The Tower (Remote Watcher)...")
    
    # Use explicit remote root to find launch_tower
    tower_script = f"{remote_root}/.mission/tools/bin/launch_tower"
    
    # Fallback logic if root is '.', try typical locations
    if remote_root == ".":
         tower_cmd = (
            "if [ -f .mission/tools/bin/launch_tower ]; then ./.mission/tools/bin/launch_tower; "
            "elif [ -f /mission/tools/bin/launch_tower ]; then /mission/tools/bin/launch_tower; "
            "else echo 'Tower script not found at ./.mission or /mission'; fi"
        )
    else:
        tower_cmd = f"if [ -f {tower_script} ]; then {tower_script}; else echo 'Tower script not found at {tower_script}'; fi"
    
    ssh_opts = ["-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null"]

    run_command(["ssh"] + ssh_opts + [host_target, tower_cmd], capture_stderr=False)


def do_pull(args):
    """Pulls a file from the host."""
    config = load_config()
    host = config['host_target']
    remote_root = config.get('remote_root', '.')
    
    input_path = args.file
    
    # Resolve Remote Path
    if input_path.startswith("/"):
        remote_path = input_path
        # For absolute paths, we store them as full structure
        rel_path = input_path.lstrip("/")
    else:
        # For relative paths, prepend remote_root
        remote_path = f"{remote_root}/{input_path}".replace(os.path.sep, "/")
        rel_path = input_path

    print(f"Pulling {remote_path} from {host}...")
    
    # 1. Verify file exists on host
    ssh_opts = ["-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null"]
    try:
        run_command(["ssh"] + ssh_opts + [host, f"test -f {remote_path}"])
    except subprocess.CalledProcessError:
        print(f"Error: File '{remote_path}' not found on remote host.")
        sys.exit(1)
    
    # 2. Rsync file to hologram/
    local_dest = os.path.join(HOLOGRAM_DIR, rel_path)
    os.makedirs(os.path.dirname(local_dest), exist_ok=True)
    
    rsync_cmd = ["rsync", "-az", "-e", "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null", f"{host}:{remote_path}", local_dest]
    run_command(rsync_cmd)
    print(f"Synced to {local_dest}")
    
    # 3. Real Auto-Ghost (Dependency Syncing)
    print("Running Auto-Ghost logic...")
    
    # Use remote_root if available to find auto_ghost
    # We loaded config at start of do_pull
    remote_root = config.get('remote_root', '.')
    
    # If remote_root is absolute, use it directly
    if remote_root.startswith("/"):
        auto_ghost_bin = f"{remote_root}/.mission/tools/bin/auto_ghost"
    else:
        # Fallback to dynamic discovery
        auto_ghost_bin = "$(git rev-parse --show-toplevel 2>/dev/null || echo '.')/.mission/tools/bin/auto_ghost"
        
    cmd_ghost = f"cd $(dirname {remote_path}) && {auto_ghost_bin} {remote_path}"
    
    try:
        json_output = run_command(["ssh"] + ssh_opts + [host, cmd_ghost], capture_stderr=False)
        dependencies = json.loads(json_output)
    except Exception as e:
        print(f"Warning: Auto-Ghost failed or returned invalid data: {e}")
        dependencies = []

    print(f"Auto-Ghost found {len(dependencies)} implicit dependencies.")
    
    # Step 3b: Sync Dependencies to Outside Wall
    for dep_path in dependencies:
        if not dep_path.startswith("/"):
             continue 

        # Map to outside_wall
        # Remove leading slash to resolve against OUTSIDE_WALL_DIR
        rel_dep = dep_path.lstrip("/")
        dest_path = os.path.join(OUTSIDE_WALL_DIR, rel_dep)
        
        if os.path.exists(dest_path):
             os.chmod(dest_path, 0o644) # Make writable for rsync

        # Sync it
        print(f"  Ghosting: {dep_path}")
        os.makedirs(os.path.dirname(dest_path), exist_ok=True)
        ghost_rsync = ["rsync", "-az", "-e", "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null", f"{host}:{dep_path}", dest_path]
        try:
            run_command(ghost_rsync)
            # Enforce The Wall (Read-Only)
            os.chmod(dest_path, 0o444)
        except Exception as e:
            print(f"  Failed to ghost {dep_path}: {e}")



def trigger_build(config):
    """Triggers the remote build via DDD."""
    host = config['host_target']
    remote_root = config.get('remote_root', '.')
    
    # Use remote_root to find .ddd
    build_req = f"{remote_root}/.ddd/run/build.request"
    
    print("Triggering remote build...")
    ssh_opts = ["-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null"]
    
    # Ensure run directory exists
    req_dir = os.path.dirname(build_req)
    # Ignore errors (best effort)
    try:
         run_command(["ssh"] + ssh_opts + [host, f"mkdir -p {req_dir}"])
    except Exception:
         pass

    run_command(["ssh"] + ssh_opts + [host, f"touch {build_req}"])

def do_build(args):
    """Explicitly triggers the remote build."""
    config = load_config()
    trigger_build(config)
    print("‚úÖ Build triggered.")

def do_push(args, trigger=False):
    """Pushes a file back to the host."""
    config = load_config()
    host = config['host_target']
    remote_root = config.get('remote_root', '.')
    local_path = args.file

    # Check for CLI override
    if hasattr(args, 'trigger') and args.trigger:
        trigger = True
    
    abs_path = os.path.abspath(local_path)
    hologram_abs = os.path.abspath(HOLOGRAM_DIR)
    wall_abs = os.path.abspath(OUTSIDE_WALL_DIR)
    
    # 1. Check The Wall
    if abs_path.startswith(wall_abs):
        print("üõë VIOLATION: The Wall Breach Detected!")
        print(f"File {local_path} is in the Read-Only 'Outside Wall' zone.")
        print("You cannot push dependencies.")
        sys.exit(1)
        
    # 2. Check Valid Hologram File
    if not abs_path.startswith(hologram_abs):
        print(f"Error: File {local_path} is not in the hologram directory.")
        sys.exit(1)
        
    # 3. Calculate remote path
    rel_path = os.path.relpath(abs_path, hologram_abs)
    # remote_root comes from config (loaded at start of do_push)
    # Ensure standard slash for remote path regardless of local OS
    remote_path = f"{remote_root}/{rel_path}".replace(os.path.sep, "/")
    
    print(f"Pushing {local_path} to {host}:{remote_path}...")
    
    # Ensure remote directory exists
    remote_dir = os.path.dirname(remote_path)
    if remote_dir and remote_dir != ".":
         ssh_opts = ["-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null"]
         # We ignore errors here in case it's a permission thing or exists, rsync will complain if it realy fails
         try:
             run_command(["ssh"] + ssh_opts + [host, f"mkdir -p {remote_dir}"])
         except Exception:
             pass

    rsync_cmd = ["rsync", "-az", "-e", "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null", local_path, f"{host}:{remote_path}"]
    run_command(rsync_cmd)
    
    if trigger:
        trigger_build(config)
        print("Sync & Trigger complete.")
    else:
        print("Sync complete (No Trigger).")

def do_listen(args):
    """Listens to the Mission Radio (remote build logs)."""
    config = load_config()
    host = config['host_target']
    remote_root = config.get('remote_root', '.')
    
    # Location: .ddd/run/build.log (relative to remote_root)
    remote_log = f"{remote_root}/.ddd/run/build.log"
    
    print(f"üì° Tuning into Mission Radio on {host}...")
    print(f"   (Watching {remote_log})")
    
    ssh_opts = ["-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null"]
    
    cmd = ["ssh"] + ssh_opts + [host, f"tail -F {remote_log} 2>/dev/null"]
    
    try:
        # We process stdout line by line
        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, bufsize=1)
        
        while True:
            raw_line = process.stdout.readline()
            if not raw_line:
                break
            
            # Mirror to local file if requested
            if hasattr(args, 'mirror_log') and args.mirror_log:
                try:
                    with open(args.mirror_log, 'a') as f:
                        f.write(raw_line)
                except Exception as e:
                    pass # Don't crash listener on local IO error

            line = raw_line.strip()
            if not line:
                continue
                
            if line.startswith("[RADIO]"):
                # Parse Signal
                payload_str = line[len("[RADIO]"):].strip()
                try:
                    payload = json.loads(payload_str)
                    event = payload.get("event")
                    msg = payload.get("message")
                    ts = payload.get("timestamp")
                    
                    # Visual Formatting
                    if event == "BUILD_START":
                        print(f"\nüöÄ [MISSION START] {ts}")
                        print(f"   >> {msg}")
                    elif event == "BUILD_SUCCESS":
                        print(f"‚úÖ [MISSION COMPLETE] {ts}")
                        print(f"   >> {msg}\n")
                    elif event == "BUILD_FAILURE":
                        print(f"‚ùå [MISSION FAILED] {ts}")
                        print(f"   >> {msg}\n")
                    else:
                        print(f"‚ÑπÔ∏è  [RADIO] {event}: {msg}")
                        
                except json.JSONDecodeError:
                    print(f"‚ö†Ô∏è  [RADIO CORRUPT] {line}")
            else:
                print(f"   [log] {line}")
                
    except KeyboardInterrupt:
        print("\nüëã Radio off.")
        sys.exit(0)
    except Exception as e:
        print(f"Error listening: {e}")
        sys.exit(1)



def do_live(args):
    """Reflex + Impulse + Synthesis: Live Mode"""
    print("üß† The Synapse is active. (Live Mode)")
    
    # 1. Start Synthesis (The Radio) in a background thread
    print("üëÇ Connecting to The Radio...")

    # Configure Log Mirroring to Hologram
    # We mirror the remote build log to local hologram/.ddd/run/build.log
    # This allows 'Local Smith' to see the logs as if they were local files.
    mirror_path = os.path.join(HOLOGRAM_DIR, ".ddd", "run", "build.log")
    os.makedirs(os.path.dirname(mirror_path), exist_ok=True)
    args.mirror_log = mirror_path
    
    print(f"ü™û Mirroring logs to {mirror_path}")

    radio_thread = threading.Thread(target=do_listen, args=(args,), daemon=True)
    radio_thread.start()
    
    # 2. Start Reflex (Watcher) & Impulse (Auto-Push)
    print("üëÅÔ∏è  Watching hologram for changes...")
    
    # Simple timestamp-based polling
    poll_interval = 1.0 # seconds
    debounce_delay = 0.5
    
    last_mtimes = {}
    pending_changes = set()
    
    # Initial scan to populate mtimes
    if os.path.exists(HOLOGRAM_DIR):
        for root, dirs, files in os.walk(HOLOGRAM_DIR):
            for f in files:
                path = os.path.join(root, f)
                try:
                    last_mtimes[path] = os.path.getmtime(path)
                except OSError:
                    pass
    else:
        print(f"Warning: {HOLOGRAM_DIR} does not exist. Please run 'projector init' first.")
        # We continue anyway, as it might be created later or user might want to init in another terminal
                
    try:
        while True:
            time.sleep(poll_interval)
            
            # Scan for changes
            current_changes = set()
            if os.path.exists(HOLOGRAM_DIR):
                for root, dirs, files in os.walk(HOLOGRAM_DIR):
                    for f in files:
                        path = os.path.join(root, f)
                        try:
                            mtime = os.path.getmtime(path)
                            if path not in last_mtimes:
                                last_mtimes[path] = mtime
                                current_changes.add(path)
                            elif mtime > last_mtimes[path]:
                                last_mtimes[path] = mtime
                                current_changes.add(path)
                        except OSError:
                            pass
            
            if current_changes:
                # Add to pending and wait for debounce
                pending_changes.update(current_changes)
                print(f"‚ö° Reflex: Detected {len(current_changes)} changes. Debouncing...")
                time.sleep(debounce_delay)
                
                # Impulse: Push all pending changes
                files_to_push = list(pending_changes)
                pending_changes.clear()
                
                for f_path in files_to_push:
                    if os.path.exists(f_path): # Check again
                        print(f"üåä Impulse: Pushing {f_path}...")
                        # Create a dummy args object
                        class PushArgs:
                            file = f_path
                        
                        try:
                            # We don't trigger per file anymore
                            do_push(PushArgs(), trigger=False)
                        except SystemExit:
                             # do_push calls sys.exit(1) on failure, we must catch it
                            print(f"‚ö†Ô∏è Push failed for {f_path}")
                        except Exception as e:
                            print(f"‚ö†Ô∏è Error pushing {f_path}: {e}")
                            
                # Trigger ONCE after batch (if auto-build is enabled)
                if args.auto_build:
                    print("Triggering remote build for batch...")
                    trigger_build(load_config())
                    print("‚ú® Synced & Triggered.")
                else:
                    print("‚ú® Synced (Use 'projector build' or run with --auto-build to trigger).")

    except KeyboardInterrupt:
        print("\nüîå Disconnecting Synapse.")
        sys.exit(0)


def main():
    parser = argparse.ArgumentParser(description="Projector Agent: Manage Remote Brain Hologram")
    subparsers = parser.add_subparsers(dest="command", required=True)
    
    # Init
    p_init = subparsers.add_parser("init", help="Initialize hologram")
    p_init.add_argument("host_target", help="SSH target (user@host)")
    p_init.add_argument("--remote-root", help="Absolute path to remote repository root", default=".")
    p_init.set_defaults(func=do_init)
    
    # Pull
    p_pull = subparsers.add_parser("pull", help="Pull file from host")
    p_pull.add_argument("file", help="Remote absolute file path")
    p_pull.set_defaults(func=do_pull)
    
    # Push
    p_push = subparsers.add_parser("push", help="Push file to host")
    p_push.add_argument("file", help="Local file path")
    p_push.add_argument("--trigger", action="store_true", help="Trigger remote build after push")
    p_push.set_defaults(func=do_push)
    
    # Listen
    p_listen = subparsers.add_parser("listen", help="Listen to remote broadcast")
    p_listen.add_argument("--mirror-log", help="Path to mirror raw log file locally")
    p_listen.set_defaults(func=do_listen)
    
    # Build
    p_build = subparsers.add_parser("build", help="Trigger remote build manually")
    p_build.set_defaults(func=do_build)
    
    # Live
    p_live = subparsers.add_parser("live", help="Live mode (Watch + Push + Listen)")
    p_live.add_argument("--auto-build", action="store_true", help="Enable automatic build triggering on file changes")
    p_live.set_defaults(func=do_live)
    
    args = parser.parse_args()
    args.func(args)

if __name__ == "__main__":
    main()
