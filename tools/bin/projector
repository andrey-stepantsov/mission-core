#!/usr/bin/env python3
import argparse
import os
import sys
import subprocess
import json
import shutil

HOLOGRAM_DIR = "hologram"
OUTSIDE_WALL_DIR = "outside_wall"
CONFIG_FILE = ".hologram_config"

def run_command(cmd, shell=False, capture_stderr=True):
    """Runs a shell command and returns stdout."""
    try:
        stderr_dest = subprocess.PIPE if capture_stderr else sys.stderr
        result = subprocess.run(cmd, shell=shell, check=True, stdout=subprocess.PIPE, stderr=stderr_dest, text=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"Error running command: {cmd}")
        print(f"Stderr: {e.stderr}")
        sys.exit(1)

def load_config():
    if not os.path.exists(CONFIG_FILE):
        print("Error: Hologram not initialized. Run 'projector init <host>' first.")
        sys.exit(1)
    with open(CONFIG_FILE, 'r') as f:
        return json.load(f)

def save_config(config):
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=4)

def do_init(args):
    """Initializes the hologram environment."""
    host_target = args.host_target
    print(f"Initializing Hologram for host: {host_target}")
    
    os.makedirs(HOLOGRAM_DIR, exist_ok=True)
    os.makedirs(OUTSIDE_WALL_DIR, exist_ok=True)
    
    config = {"host_target": host_target}
    save_config(config)
    print("Hologram initialized.")

def do_pull(args):
    """Pulls a file from the host."""
    config = load_config()
    host = config['host_target']
    remote_path = args.file
    
    print(f"Pulling {remote_path} from {host}...")
    
    # 1. Verify file exists on host
    ssh_opts = ["-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null"]
    run_command(["ssh"] + ssh_opts + [host, f"test -f {remote_path}"])
    
    # 2. Rsync file to hologram/
    # Preserve directory structure
    rel_path = remote_path.lstrip("/")
    local_dest = os.path.join(HOLOGRAM_DIR, rel_path)
    os.makedirs(os.path.dirname(local_dest), exist_ok=True)
    
    rsync_cmd = ["rsync", "-az", "-e", "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null", f"{host}:{remote_path}", local_dest]
    run_command(rsync_cmd)
    print(f"Synced to {local_dest}")
    
    # 3. Real Auto-Ghost (Dependency Syncing)
    print("Running Auto-Ghost logic...")
    
    # Check if auto_ghost tool exists remotely
    # We call it via SSH. it's in the same bin path relative to repo usually, but we need to know where it is.
    # Assumption: The 'repo root' on remote is parent of 'tools/bin'. 
    # But we don't know the remote repo root easily unless we assume standard layout.
    # Let's assume standard layout: tools/bin/auto_ghost is available in the same relative path.
    # BUT, we might not know the exact path on remote unless we know where the repo is.
    # WORKAROUND: We assume the user initialized with a path or we can infer from the file path if it's inside the repo.
    # However, 'projector init' doesn't seem to store repo root. 
    # Let's try to assume 'tools/bin/auto_ghost' is in the PATH or mapped.
    # Actually, the user's design says: "auto_ghost is just a stub". 
    # Let's assume we invoke it by absolute path if we can find it, or relative to the file?
    # Better approach for now: execute `tools/bin/auto_ghost` assuming the repo structure.
    # We can try to guess the repo root from the file path (walking up). 
    # OR simpler: We just use the known location relative to the 'mission' or 'chaos' root if standard.
    # Let's assume the remote has 'tools/bin/auto_ghost' in the 'dev/chaos/.mission' or similar if that's what we are editing.
    # Wait, the PROMPT says: "Analyze docs/... and tools/bin/weave".
    # The file structure seems to be: .mission/tools/bin/auto_ghost.
    # So we can construct the command based on that.
    
    # HACK: For this specific task, we will try to find auto_ghost relative to the FILE being pulled if possible, 
    # or just assume it is in <repo_root>/.mission/tools/bin/auto_ghost
    # Since we don't know repo root, let's try to find it via a helper command or just search?
    # Let's assume the standard path: <remote_path_to_repo>/.mission/tools/bin/auto_ghost.
    # But we only have <remote_path>.
    
    # Let's fetch the dependency list by running a command that finds the tool.
    # We will try to run: "cd $(dirname <remote_file>) && ../../tools/bin/auto_ghost <remote_file>" 
    # or search up.
    # A robust way is to ask the host "where is auto_ghost?". 
    # For now, let's try to run `auto_ghost` assuming it is in the path or we construct a path.
    # Given the context: "tools/bin/projector" is running on client.
    # We need to run "tools/bin/auto_ghost" on HOST.
    # Let's use a heuristic: Assume the binary is at `path/to/repo/.mission/tools/bin/auto_ghost`.
    # We can try to locate it.
    
    # Step 3a: Get dependencies
    cmd_ghost = f"cd $(dirname {remote_path}) && $(git rev-parse --show-toplevel 2>/dev/null || echo '.')/.mission/tools/bin/auto_ghost {remote_path}"
    
    try:
        json_output = run_command(["ssh"] + ssh_opts + [host, cmd_ghost], capture_stderr=False)
        dependencies = json.loads(json_output)
    except Exception as e:
        print(f"Warning: Auto-Ghost failed or returned invalid data: {e}")
        dependencies = []

    print(f"Auto-Ghost found {len(dependencies)} implicit dependencies.")
    
    # Step 3b: Sync Dependencies to Outside Wall
    for dep_path in dependencies:
        if not dep_path.startswith("/"):
             continue 

        # Map to outside_wall
        # Remove leading slash to resolve against OUTSIDE_WALL_DIR
        rel_dep = dep_path.lstrip("/")
        dest_path = os.path.join(OUTSIDE_WALL_DIR, rel_dep)
        
        # Skip if already exists (optimization)? 
        # No, we should update it to ensure we match the Host state.
        # But we must chmod it to +w before overwriting if it exists and is 444.
        if os.path.exists(dest_path):
             os.chmod(dest_path, 0o644) # Make writable for rsync

        # Sync it
        print(f"  Ghosting: {dep_path}")
        os.makedirs(os.path.dirname(dest_path), exist_ok=True)
        ghost_rsync = ["rsync", "-az", "-e", "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null", f"{host}:{dep_path}", dest_path]
        try:
            run_command(ghost_rsync)
            # Enforce The Wall (Read-Only)
            os.chmod(dest_path, 0o444)
        except Exception as e:
            print(f"  Failed to ghost {dep_path}: {e}")


def do_push(args):
    """Pushes a file back to the host."""
    config = load_config()
    host = config['host_target']
    local_path = args.file
    
    abs_path = os.path.abspath(local_path)
    hologram_abs = os.path.abspath(HOLOGRAM_DIR)
    wall_abs = os.path.abspath(OUTSIDE_WALL_DIR)
    
    # 1. Check The Wall
    if abs_path.startswith(wall_abs):
        print("ðŸ›‘ VIOLATION: The Wall Breach Detected!")
        print(f"File {local_path} is in the Read-Only 'Outside Wall' zone.")
        print("You cannot push dependencies.")
        sys.exit(1)
        
    # 2. Check Valid Hologram File
    if not abs_path.startswith(hologram_abs):
        print(f"Error: File {local_path} is not in the hologram directory.")
        sys.exit(1)
        
    # 3. Calculate remote path
    rel_path = os.path.relpath(abs_path, hologram_abs)
    remote_path = "/" + rel_path # Assuming absolute paths on remote for simplicity
    
    print(f"Pushing {local_path} to {host}:{remote_path}...")
    rsync_cmd = ["rsync", "-az", "-e", "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null", local_path, f"{host}:{remote_path}"]
    run_command(rsync_cmd)
    print("Sync complete.")

def main():
    parser = argparse.ArgumentParser(description="Projector Agent: Manage Remote Brain Hologram")
    subparsers = parser.add_subparsers(dest="command", required=True)
    
    # Init
    p_init = subparsers.add_parser("init", help="Initialize hologram")
    p_init.add_argument("host_target", help="SSH target (user@host)")
    p_init.set_defaults(func=do_init)
    
    # Pull
    p_pull = subparsers.add_parser("pull", help="Pull file from host")
    p_pull.add_argument("file", help="Remote absolute file path")
    p_pull.set_defaults(func=do_pull)
    
    # Push
    p_push = subparsers.add_parser("push", help="Push file to host")
    p_push.add_argument("file", help="Local file path")
    p_push.set_defaults(func=do_push)
    
    args = parser.parse_args()
    args.func(args)

if __name__ == "__main__":
    main()
